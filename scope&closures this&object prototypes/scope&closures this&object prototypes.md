# SCOPE & CLOSURES THIS & OBJECT PROTOTYPES

##  Scope

### 作用域

#### 编译原理

传统编译语言的流程中，源码执行前经历三个步骤，统称为“编译”

- 分词/词法分析

  var a = 2

  会拆分成 var、a、=、2 （空格是否会被当作词法单元，取决于空格在语言中是否具有意义）

- 解析/语法分析

  这个过程将词法单元流转化成一个元素逐级嵌套所组成代表程序语法结构的树，树被成为**“抽象语法树”**

  var a = 2; 的抽象语法树会有一个叫VariableDeclaration的顶级节点，接下来是叫做Identifier（值是a）的子节点，以及一个叫做AssignmentExpression的子节点。AssignmentExpression节点有一个叫NumericLiteral（值为2）的子节点

- 代码生成

  将抽象语法树转换为可执行代码的过程被称为代码生成，过程与语言、目标平台等息息相关

  就是将var a = 2; 的抽象语法树转化为一组机器指令，用来创建一个叫作a的变量，并将一个值存储在a中

比起以上传统编译语言，JavaScript引擎更为复杂，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化

首先，JavaScript 不会有大量时间优化，因为 **JavaScript的编译过程不是发生在构建之前**，对于JavaScript而言，大部分情况下编译发生在代码执行前几微秒。



#### 理解作用域

学习作用域的方法：将过程模拟成几个人物之间的对话

##### 演员表

对 var a = 2; 进行处理的演员

- 引擎

  从头到尾负责整个JavaScript程序的编译和执行过程

- 编译器

  引擎的好朋友之一，负责语法分析和代码生成等脏活累活

- 作用域

  引擎的另一位朋友，负责收集并维护由所有声明的标识符（变量）组成一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

##### 对话

一般而言，var a = 2; 我们认为是一句声明，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，一个由引擎在运行时处理

编译器：

1. 遇到var a，会询问作用域是否已经有一个该名称的变量存在于同一个作用域中的集合中，如果是，会忽略该声明继续编译，否则会要求作用域在当前作用域集合中声明一个新的变量，并命名为a
2. 接下来编译器会为引擎生成运行时需要的代码，这些代码被用来处理 a = 2 ，这一操作。引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫 a 的变量。如果是就会使用这个变量，如果否会继续查找该变量

如果引擎最后找到了 a，就会将 2 赋给它，否则引擎就会抛出一个异常

**总结：**变量赋值会执行两个动作，首先在当前作用域中声明一个变量，然后在运行时会在作用域中查找该变量，如果找到就进行赋值

##### 编译器有话说

引擎执行编译器生成的代码时，会通过变量a来判断是否已经声明过。查找的过程由作用域协助，但是怎么查找，会影响最终的查找结果

引擎会为a进行LHS查询，另一个查找的类型叫做RHS

L：左	R：右

指的是赋值操作的左侧和右侧

准确的讲：RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是视图找到变量的容器本身，从而对其赋值。在这个角度来说，RHS不是真正意义上的赋值操作的右侧，而是非左侧，

**例子1：**

```javascript
console.log(a);
```

对于a的引用是一个RHS，因为a没有赋予任何值，相应的要查找并取得a的值才能传递给console.log(..)

**例子2：**

```javascript
a = 2;
```

这里对a的引用是LHS，因为实际上我们不关心当前值，只想要为2这个赋值操作找到一个目标

**注意：**概念上最好理解为**（赋值操作的目标是谁）LHS**和**（赋值操作的源头是谁）RHS**

**综合案例：**

```javascript
function foo(a){
	console.log(a);
}
foo(2);
```

最后一行foo(..)进行RHS，“意味着去找foo的值并且把他给我“

代码中隐式的 a = 2 是存在的，操作发生在2被当作参数传递给foo(..)函数时，2会分配给参数a，为了给a分配值，需要进行一次LHS查询

这里还有对a进行的RHS引用，将得到的值传给了console.log(..)

console.log(..)本身也需要一个引用才能执行，因此会对console对象进行RHS查询，并且检查是否有log方法

最后在概念上理解为LHS和RHS之间通过对值2进行交互来将其传递进log(..)

##### 小测验

找到下列代码的所有LHS查询和所有RHS查询

```javascript
function foo(a){
	var b = a;
	return a + b;
}

var c = foo(2);
```

- LHS:   b = ..   、c = ..   、a = 2(隐式)
- RHS：foo(2..   、= a   、a   、b

