# SCOPE & CLOSURES THIS & OBJECT PROTOTYPES

##  Scope

### 作用域

#### 编译原理

传统编译语言的流程中，源码执行前经历三个步骤，统称为“编译”

- 分词/词法分析

  var a = 2

  会拆分成 var、a、=、2 （空格是否会被当作词法单元，取决于空格在语言中是否具有意义）

- 解析/语法分析

  这个过程将词法单元流转化成一个元素逐级嵌套所组成代表程序语法结构的树，树被成为**“抽象语法树”**

  var a = 2; 的抽象语法树会有一个叫VariableDeclaration的顶级节点，接下来是叫做Identifier（值是a）的子节点，以及一个叫做AssignmentExpression的子节点。AssignmentExpression节点有一个叫NumericLiteral（值为2）的子节点

- 代码生成

  将抽象语法树转换为可执行代码的过程被称为代码生成，过程与语言、目标平台等息息相关

  就是将var a = 2; 的抽象语法树转化为一组机器指令，用来创建一个叫作a的变量，并将一个值存储在a中

比起以上传统编译语言，JavaScript引擎更为复杂，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化

首先，JavaScript 不会有大量时间优化，因为 **JavaScript的编译过程不是发生在构建之前**，对于JavaScript而言，大部分情况下编译发生在代码执行前几微秒。



#### 理解作用域

学习作用域的方法：将过程模拟成几个人物之间的对话

##### 演员表

对 var a = 2; 进行处理的演员

- 引擎

  从头到尾负责整个JavaScript程序的编译和执行过程

- 编译器

  引擎的好朋友之一，负责语法分析和代码生成等脏活累活

- 作用域

  引擎的另一位朋友，负责收集并维护由所有声明的标识符（变量）组成一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

##### 对话

一般而言，var a = 2; 我们认为是一句声明，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，一个由引擎在运行时处理

编译器：

1. 遇到var a，会询问作用域是否已经有一个该名称的变量存在于同一个作用域中的集合中，如果是，会忽略该声明继续编译，否则会要求作用域在当前作用域集合中声明一个新的变量，并命名为a
2. 接下来编译器会为引擎生成运行时需要的代码，这些代码被用来处理 a = 2 ，这一操作。引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫 a 的变量。如果是就会使用这个变量，如果否会继续查找该变量

如果引擎最后找到了 a，就会将 2 赋给它，否则引擎就会抛出一个异常

**总结：**变量赋值会执行两个动作，首先在当前作用域中声明一个变量，然后在运行时会在作用域中查找该变量，如果找到就进行赋值

##### 编译器有话说

引擎执行编译器生成的代码时，会通过变量a来判断是否已经声明过。查找的过程由作用域协助，但是怎么查找，会影响最终的查找结果

引擎会为a进行LHS查询，另一个查找的类型叫做RHS

L：左	R：右

指的是赋值操作的左侧和右侧

准确的讲：RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是视图找到变量的容器本身，从而对其赋值。在这个角度来说，RHS不是真正意义上的赋值操作的右侧，而是非左侧，

**例子1：**

```javascript
console.log(a);
```

对于a的引用是一个RHS，因为a没有赋予任何值，相应的要查找并取得a的值才能传递给console.log(..)

**例子2：**

```javascript
a = 2;
```

这里对a的引用是LHS，因为实际上我们不关心当前值，只想要为2这个赋值操作找到一个目标

**注意：**概念上最好理解为**（赋值操作的目标是谁）LHS**和**（赋值操作的源头是谁）RHS**

**综合案例：**

```javascript
function foo(a){
	console.log(a);
}
foo(2);
```

最后一行foo(..)进行RHS，“意味着去找foo的值并且把他给我“

代码中隐式的 a = 2 是存在的，操作发生在2被当作参数传递给foo(..)函数时，2会分配给参数a，为了给a分配值，需要进行一次LHS查询

这里还有对a进行的RHS引用，将得到的值传给了console.log(..)

console.log(..)本身也需要一个引用才能执行，因此会对console对象进行RHS查询，并且检查是否有log方法

最后在概念上理解为LHS和RHS之间通过对值2进行交互来将其传递进log(..)

##### 小测验

找到下列代码的所有LHS查询和所有RHS查询

```javascript
function foo(a){
	var b = a;
	return a + b;
}

var c = foo(2);
```

- LHS:   b = ..   、c = ..   、a = 2(隐式)
- RHS：foo(2..   、= a   、a   、b



#### 作用域嵌套

作用域是根据名称查找变量的一套规则，实际情况中，通常需要顾及几个作用域

当一个块或作用域嵌套在另一个块或函数中，就发生了作用域嵌套

```javascript
function foo(a){
	console.log( a + b );
}

var b = 2;

foo(2)
```

对b进行的RHS引用无法在foo函数内部完成，但可以在上一级作用域中完成

##### 把作用域链比喻成一个建筑

第一次层就代表当前的作用域，没有找到就继续往上一层层查找，直到顶层（全局作用域），然后停止（无论是否找到）



#### 异常

区分LHS和RHS是一件重要的事，因为在变量还没声明的情况下，这两种查询的行为不同

```javascript
function foo(a){
	console.log( a + b );
	b = a;
}
foo(2);
```

第一次对b进行查找无论如何都找不到该变量，也就是说这是一个”未声明“的变量，因为在任何作用域中都无法找到它

如果RHS查询在所有嵌套的作用域中遍寻不到所需要的变量，**引擎**会抛出 **ReferenceError** 异常， **ReferenceError** 是非常重要的异常类型

相较之下，引擎执行 LHS 查询时，如果在全局作用域也无法找到目标变量，会创建一个具有该名称的变量，将其返回给引擎，前提是程序运行在**”非严格模式“**下

**严格模式：**ES5开始引入的，此模式在行为上有很多不同，其中一个就是禁止自动或隐式地创建全局变量，因此在严格模式中 LHS 查询失败的话，不会返回一个全局变量，会抛出同 RHS 查询失败时类似的 **ReferenceError** 异常

RHS 查询到了一个变量，但是如果对这个变量的值进行不合理操作，比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫做 **TypeError**

**重点：**

- **ReferenceError：**同作用域判别失败相关
- **TypeError：**作用域判别成功，但是对操作的结果是非法或者不合理的



### 词法作用域

作用域共有两种主要的工作模型：

- 第一种：最为普通，被大多数编程语言所采用，我们会对这种作用域深入讨论
- 第二种：动态作用域，仍有一些语言在使用（Bash脚本，Perl中的一些模式）



#### 词法阶段

大部分标准语言编译器第一个工作阶段叫词法化（单词化），词法化过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义

这个概念是理解词法作用域及其名称来历的基础

简单理解，**词法作用域** 就是定义在词法阶段的作用域。换句话说，是在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况是这样）

**注意：**后面会介绍一些欺骗词法作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域，但是这种机制可能会难以理解。事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践

**例子：**

```javascript
function foo(a){
	var b = a * 2;
	
	function bar(c){
		console.log(a, b, c);
	}
    
	bar(b * 3);
}
foo(2);
```

1. 全局作用域，只有一个标识符：foo
2. 包含foo创建的作用域，三个标识符：a、bar、b
3. 包含bar创建的作用域，只有一个标识符：c

作用域气泡是逐级包含的，下一章讨论不同类型的作用域，现在假设每一个函数都会创建一个新的作用域气泡

bar的气泡被完全包含在foo所创建的气泡中，唯一的原因是那里就是我们希望定义函数bar的位置

##### 查找

作用域气泡的结构和相互之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置

关于上面的例子：

```javascript
function foo(a){
	var b = a * 2;
	
	function bar(c){
		console.log(a, b, c);
	}
    
	bar(b * 3);
}
foo(2);
```

console.log(a, b, c) 从 bar 开始查找，然后去 foo 没然后找到了 a，因此引擎使用了这个引用

`作用域查找会在找到第一个匹配的标识符时停止。` 在多层嵌套作用域中可以定义同名的标识符，这叫做`遮蔽效应（内部标识符'遮蔽'了外部标识符）`。

**注意：**全局变量会自动成为全局对象，比如浏览器中window对象的属性，因此可以不直接通过全局变量的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问

`window.a`

通过这种技术可以访问那些被同名变量所遮蔽的全局变量，但非全局变量如果被遮蔽，则无法访问到

